<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gold Profile Picture Generator</title>
        <style>
        * { box-sizing: border-box; }
        body {
            font-family: system-ui, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 { color: #d4af37; }
        .upload-area {
            border: 2px dashed #d4af37;
            border-radius: 12px;
            padding: 40px;
            margin: 20px 0;
            cursor: pointer;
            max-width: 400px;
            text-align: center;
        }
        .upload-area:hover { background: rgba(212,175,55,0.1); }
        .preview {
            background: repeating-conic-gradient(#666 0% 25%, #444 0% 50%) 50% / 16px 16px;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        canvas { display: block; }
        button {
            background: linear-gradient(135deg, #f4d03f, #c9a227, #8b7355, #c9a227, #f4d03f);
            color: #000;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
        }
        button:hover { transform: scale(1.02); }
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .hidden { display: none; }
        #output {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .toggle label {
            cursor: pointer;
        }
        .examples {
            display: flex;
            gap: 40px;
            margin-top: 40px;
        }
        .example {
            text-align: center;
        }
        .example img {
            max-width: 150px;
        }
        .gallery {
            margin-top: 40px;
            text-align: center;
        }
        .gallery h2 {
            color: #d4af37;
            margin-bottom: 20px;
        }
        .gallery-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            max-width: 800px;
        }
        .gallery-grid img {
            max-width: 120px;
            max-height: 120px;
            border-radius: 50%;
            object-fit: cover;
        }
        .progress-container {
            width: 100%;
            max-width: 300px;
            margin: 10px 0;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #f4d03f, #c9a227);
            width: 0%;
            transition: width 0.1s;
        }
        .progress-text {
            text-align: center;
            margin-top: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Gold Profile Picture Generator</h1>

    <div class="upload-area" onclick="document.getElementById('file').click()">
        <input type="file" id="file" accept="image/*" style="display:none">
        <p>Click to upload image</p>
    </div>
    <p style="font-size: 12px; color: #888; margin-top: 5px;">Supports PNG, JPG, GIF, WebP, and animated WebP/GIF</p>

    <div class="toggle">
        <input type="checkbox" id="theme2025">
        <label for="theme2025">2025 Theme (gray background)</label>
    </div>

    <div id="output" class="hidden">
        <div class="preview">
            <canvas id="canvas"></canvas>
        </div>
        <div id="progressContainer" class="progress-container hidden">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
            <div id="progressText" class="progress-text"></div>
        </div>
        <button id="downloadBtn" onclick="download()">Download PNG</button>
    </div>

    <div class="examples">
        <div class="example">
            <img src="img/before.png" alt="Before">
            <p>Go from this</p>
        </div>
        <div class="example">
            <img src="img/after.png" alt="After">
            <p>to this.</p>
        </div>
        <div class="example">
            <img src="img/after2.png" alt="After 2025">
            <p>or this.</p>
        </div>
    </div>

    <div class="gallery">
        <h2>Gallery</h2>
        <div class="gallery-grid">
            <img src="img/gallery/boss-crab.gif" alt="Boss Crab">
            <img src="img/gallery/fish.gif" alt="Fish">
            <img src="img/gallery/gigachad.png" alt="Gigachad">
            <img src="img/gallery/nazrin-dance.gif" alt="Nazrin Dance">
            <img src="img/gallery/shoovy.webp" alt="Shoovy">
            <img src="img/gallery/smug-jug.gif" alt="Smug Jug">
        </div>
    </div>

    <script type="module">
        import { parseGIF, decompressFrames } from 'https://esm.sh/gifuct-js@2.1.2';
        import { GIFEncoder, quantize, applyPalette } from 'https://cdn.skypack.dev/gifenc';
        // Create animated WebP by muxing individual WebP frames
        async function createAnimatedWebP(frames, width, height) {
            // Each frame: { data: Uint8Array (WebP), delay: number (ms) }

            // Extract VP8/VP8L bitstreams (with ALPH if present) from each frame
            const payloads = [];
            let totalPayloadSize = 0;
            let hasAlpha = false;

            for (const frame of frames) {
                // Parse the WebP to find ALPH and VP8/VP8L chunks
                const data = frame.data;
                let pos = 12; // Skip RIFF header

                let alphChunk = null;
                let vp8Chunk = null;

                while (pos < data.length - 8) {
                    const fourcc = String.fromCharCode(data[pos], data[pos+1], data[pos+2], data[pos+3]);
                    const chunkSize = data[pos+4] | (data[pos+5] << 8) | (data[pos+6] << 16) | (data[pos+7] << 24);
                    const paddedSize = chunkSize + (chunkSize % 2);

                    if (fourcc === 'ALPH') {
                        alphChunk = data.slice(pos, pos + 8 + paddedSize);
                        hasAlpha = true;
                    } else if (fourcc === 'VP8 ' || fourcc === 'VP8L') {
                        vp8Chunk = data.slice(pos, pos + 8 + paddedSize);
                        if (fourcc === 'VP8L') hasAlpha = true; // VP8L has built-in alpha
                    }
                    pos += 8 + paddedSize;
                }

                // Combine ALPH + VP8 or just VP8L
                let payload;
                if (alphChunk && vp8Chunk) {
                    payload = new Uint8Array(alphChunk.length + vp8Chunk.length);
                    payload.set(alphChunk, 0);
                    payload.set(vp8Chunk, alphChunk.length);
                } else if (vp8Chunk) {
                    payload = vp8Chunk;
                } else {
                    // Fallback
                    payload = data.slice(12);
                }

                payloads.push(payload);
                const anmfDataSize = 16 + payload.length;
                totalPayloadSize += 8 + anmfDataSize + (anmfDataSize % 2);
            }

            // Total file structure:
            // RIFF header: 12 bytes
            // VP8X chunk: 8 + 10 = 18 bytes
            // ANIM chunk: 8 + 6 = 14 bytes
            // ANMF chunks: variable
            const totalSize = 12 + 18 + 14 + totalPayloadSize;

            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);
            let offset = 0;

            // RIFF header
            bytes.set([0x52, 0x49, 0x46, 0x46], 0); // "RIFF"
            view.setUint32(4, totalSize - 8, true); // File size minus RIFF header
            bytes.set([0x57, 0x45, 0x42, 0x50], 8); // "WEBP"
            offset = 12;

            // VP8X chunk (extended features)
            bytes.set([0x56, 0x50, 0x38, 0x58], offset); // "VP8X"
            view.setUint32(offset + 4, 10, true); // Chunk size
            bytes[offset + 8] = hasAlpha ? 0x12 : 0x02; // Flags: animation + alpha
            bytes[offset + 9] = 0;
            bytes[offset + 10] = 0;
            bytes[offset + 11] = 0;
            // Canvas width - 1 (24-bit LE)
            bytes[offset + 12] = (width - 1) & 0xFF;
            bytes[offset + 13] = ((width - 1) >> 8) & 0xFF;
            bytes[offset + 14] = ((width - 1) >> 16) & 0xFF;
            // Canvas height - 1 (24-bit LE)
            bytes[offset + 15] = (height - 1) & 0xFF;
            bytes[offset + 16] = ((height - 1) >> 8) & 0xFF;
            bytes[offset + 17] = ((height - 1) >> 16) & 0xFF;
            offset += 18;

            // ANIM chunk
            bytes.set([0x41, 0x4E, 0x49, 0x4D], offset); // "ANIM"
            view.setUint32(offset + 4, 6, true); // Chunk size
            view.setUint32(offset + 8, 0x00000000, true); // Background color
            view.setUint16(offset + 12, 0, true); // Loop count (0 = infinite)
            offset += 14;

            // ANMF chunks
            for (let i = 0; i < frames.length; i++) {
                const payload = payloads[i];
                const delay = frames[i].delay;
                const anmfDataSize = 16 + payload.length;

                bytes.set([0x41, 0x4E, 0x4D, 0x46], offset); // "ANMF"
                view.setUint32(offset + 4, anmfDataSize, true); // Chunk size (unpadded)

                // Frame X / 2 (24-bit LE) - position 0
                bytes[offset + 8] = 0;
                bytes[offset + 9] = 0;
                bytes[offset + 10] = 0;
                // Frame Y / 2 (24-bit LE) - position 0
                bytes[offset + 11] = 0;
                bytes[offset + 12] = 0;
                bytes[offset + 13] = 0;
                // Frame width - 1 (24-bit LE)
                bytes[offset + 14] = (width - 1) & 0xFF;
                bytes[offset + 15] = ((width - 1) >> 8) & 0xFF;
                bytes[offset + 16] = ((width - 1) >> 16) & 0xFF;
                // Frame height - 1 (24-bit LE)
                bytes[offset + 17] = (height - 1) & 0xFF;
                bytes[offset + 18] = ((height - 1) >> 8) & 0xFF;
                bytes[offset + 19] = ((height - 1) >> 16) & 0xFF;
                // Duration (24-bit LE, in ms)
                bytes[offset + 20] = delay & 0xFF;
                bytes[offset + 21] = (delay >> 8) & 0xFF;
                bytes[offset + 22] = (delay >> 16) & 0xFF;
                // Flags: blend=0, dispose=0
                bytes[offset + 23] = 0;

                // Frame data (VP8/VP8L bitstream)
                bytes.set(payload, offset + 24);
                offset += 8 + anmfDataSize;

                // Padding byte if chunk data is odd
                if (anmfDataSize % 2) {
                    bytes[offset] = 0;
                    offset++;
                }
            }

            return new Blob([buffer], { type: 'image/webp' });
        }

        let img = null;
        let isAnimated = false;
        let isWebP = false;
        let gifFrames = null;
        let webpFrames = null;
        let gifBlob = null;
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const downloadBtn = document.getElementById('downloadBtn');

        document.getElementById('file').onchange = async e => {
            const file = e.target.files[0];
            if (!file) return;

            isAnimated = false;
            isWebP = file.type === 'image/webp';
            gifFrames = null;
            webpFrames = null;
            gifBlob = null;

            if (file.type === 'image/gif') {
                await handleGif(file);
            } else if (isWebP) {
                await handleWebP(file);
            } else {
                handleStaticImage(file);
            }
        };

        function handleStaticImage(file) {
            const reader = new FileReader();
            reader.onload = ev => {
                img = new Image();
                img.onload = () => {
                    document.getElementById('output').classList.remove('hidden');
                    downloadBtn.textContent = isWebP ? 'Download WebP' : 'Download PNG';
                    downloadBtn.disabled = false;
                    render();
                };
                img.src = ev.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function handleWebP(file) {
            // Check if ImageDecoder is supported
            if (typeof ImageDecoder === 'undefined') {
                console.log('ImageDecoder not supported, falling back to static');
                handleStaticImage(file);
                return;
            }

            const arrayBuffer = await file.arrayBuffer();

            try {
                const decoder = new ImageDecoder({
                    data: arrayBuffer,
                    type: 'image/webp'
                });

                await decoder.completed;
                await decoder.tracks.ready;

                const track = decoder.tracks.selectedTrack;
                console.log('WebP tracks:', decoder.tracks, 'selected:', track, 'frameCount:', track?.frameCount);

                // Check if it's animated
                if (!track || track.frameCount <= 1) {
                    console.log('Not animated or single frame, falling back to static');
                    decoder.close();
                    handleStaticImage(file);
                    return;
                }

                document.getElementById('output').classList.remove('hidden');
                document.getElementById('progressContainer').classList.remove('hidden');
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'Processing...';
                updateProgress(0, 'Parsing WebP...');

                isAnimated = true;
                const frameCount = track.frameCount;
                const frames = [];

                for (let i = 0; i < frameCount; i++) {
                    const result = await decoder.decode({ frameIndex: i });
                    const videoFrame = result.image;

                    // Convert VideoFrame to ImageBitmap
                    const bitmap = await createImageBitmap(videoFrame);
                    const duration = Number(videoFrame.duration) / 1000; // microseconds to ms
                    videoFrame.close();

                    frames.push({
                        bitmap,
                        delay: Math.max(duration, 20) // Minimum 20ms delay
                    });
                }

                decoder.close();

                // Show first frame as preview
                const firstBitmap = frames[0].bitmap;
                const width = firstBitmap.width;
                const height = firstBitmap.height;
                img = { width, height, _gifDims: { width, height } };

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(firstBitmap, 0, 0);
                render(tempCanvas);

                // Store frames for re-processing on theme change
                webpFrames = frames;

                // Process frames
                await processWebPFrames(frames);

            } catch (e) {
                console.error('WebP decode error:', e);
                handleStaticImage(file);
            }
        }

        async function handleGif(file) {
            document.getElementById('output').classList.remove('hidden');
            document.getElementById('progressContainer').classList.remove('hidden');
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'Processing...';
            isAnimated = true;
            updateProgress(0, 'Parsing GIF...');

            const arrayBuffer = await file.arrayBuffer();
            const gif = parseGIF(arrayBuffer);
            const frames = decompressFrames(gif, true);

            gifFrames = frames;

            // Show first frame as preview
            const firstFrame = frames[0];
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = gif.lsd.width;
            tempCanvas.height = gif.lsd.height;
            const tempCtx = tempCanvas.getContext('2d');

            const imageData = tempCtx.createImageData(firstFrame.dims.width, firstFrame.dims.height);
            imageData.data.set(firstFrame.patch);
            tempCtx.putImageData(imageData, firstFrame.dims.left, firstFrame.dims.top);

            img = { width: gif.lsd.width, height: gif.lsd.height, _gifDims: gif.lsd };
            render(tempCanvas);

            // Process all frames
            await processGifFrames(frames, gif.lsd);
        }

        async function processGifFrames(frames, dims) {
            const size = Math.max(400, Math.min(dims.width, dims.height));
            const use2025Theme = document.getElementById('theme2025').checked;

            const gif = GIFEncoder();

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = dims.width;
            tempCanvas.height = dims.height;
            const tempCtx = tempCanvas.getContext('2d');

            const frameCanvas = document.createElement('canvas');
            frameCanvas.width = size;
            frameCanvas.height = size;
            const frameCtx = frameCanvas.getContext('2d', { willReadFrequently: true });

            // Create cumulative canvas for GIF frame compositing
            const cumulativeCanvas = document.createElement('canvas');
            cumulativeCanvas.width = dims.width;
            cumulativeCanvas.height = dims.height;
            const cumulativeCtx = cumulativeCanvas.getContext('2d');

            for (let i = 0; i < frames.length; i++) {
                updateProgress((i / frames.length) * 100, `Processing frame ${i + 1}/${frames.length}`);

                const frame = frames[i];

                // Handle disposal method from previous frame
                if (i > 0) {
                    const prevFrame = frames[i - 1];
                    if (prevFrame.disposalType === 2) {
                        cumulativeCtx.clearRect(prevFrame.dims.left, prevFrame.dims.top, prevFrame.dims.width, prevFrame.dims.height);
                    } else if (prevFrame.disposalType === 3) {
                        cumulativeCtx.clearRect(prevFrame.dims.left, prevFrame.dims.top, prevFrame.dims.width, prevFrame.dims.height);
                    }
                }

                // Draw current frame patch onto cumulative canvas
                const imageData = new ImageData(new Uint8ClampedArray(frame.patch), frame.dims.width, frame.dims.height);
                tempCtx.clearRect(0, 0, dims.width, dims.height);
                tempCtx.putImageData(imageData, 0, 0);
                cumulativeCtx.drawImage(tempCanvas, frame.dims.left, frame.dims.top);

                // Render this frame with gold border
                renderFrame(frameCtx, cumulativeCanvas, size);

                // Get frame data and quantize
                const frameData = frameCtx.getImageData(0, 0, size, size).data;
                const palette = quantize(frameData, 256);
                const index = applyPalette(frameData, palette);

                gif.writeFrame(index, size, size, {
                    palette,
                    delay: frame.delay || 100,
                    transparent: use2025Theme ? false : true,
                    transparentIndex: use2025Theme ? 0 : 0
                });

                // Let UI update
                await new Promise(r => setTimeout(r, 0));
            }

            gif.finish();

            const blob = new Blob([gif.bytes()], { type: 'image/gif' });
            gifBlob = blob;
            document.getElementById('progressContainer').classList.add('hidden');
            downloadBtn.textContent = 'Download GIF';
            downloadBtn.disabled = false;

            // Show animated preview
            const url = URL.createObjectURL(blob);
            const previewImg = new Image();
            previewImg.onload = () => {
                canvas.width = previewImg.width;
                canvas.height = previewImg.height;
                ctx.drawImage(previewImg, 0, 0);
            };
            previewImg.src = url;
        }

        async function processWebPFrames(frames) {
            const firstBitmap = frames[0].bitmap;
            const size = Math.max(400, Math.min(firstBitmap.width, firstBitmap.height));
            await processWebPFramesAsWebP(frames, size);
        }

        async function processWebPFramesAsWebP(frames, size) {
            const frameCanvas = document.createElement('canvas');
            frameCanvas.width = size;
            frameCanvas.height = size;
            const frameCtx = frameCanvas.getContext('2d', { willReadFrequently: true });

            const sourceCanvas = document.createElement('canvas');
            sourceCanvas.width = frames[0].bitmap.width;
            sourceCanvas.height = frames[0].bitmap.height;
            const sourceCtx = sourceCanvas.getContext('2d');

            const webpFrames = [];

            for (let i = 0; i < frames.length; i++) {
                updateProgress((i / frames.length) * 80, `Processing frame ${i + 1}/${frames.length}`);

                const frame = frames[i];

                // Draw bitmap to source canvas
                sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
                sourceCtx.drawImage(frame.bitmap, 0, 0);

                // Render this frame with gold border
                renderFrame(frameCtx, sourceCanvas, size);

                // Get frame as WebP blob
                const blob = await new Promise(resolve => frameCanvas.toBlob(resolve, 'image/webp', 0.9));
                const buffer = await blob.arrayBuffer();

                webpFrames.push({
                    data: new Uint8Array(buffer),
                    delay: frame.delay
                });

                await new Promise(r => setTimeout(r, 0));
            }

            updateProgress(80, 'Encoding animated WebP...');

            // Create animated WebP by muxing frames
            const blob = await createAnimatedWebP(webpFrames, size, size);

            gifBlob = blob;
            document.getElementById('progressContainer').classList.add('hidden');
            downloadBtn.textContent = 'Download WebP';
            downloadBtn.disabled = false;

            // Show animated preview
            const url = URL.createObjectURL(blob);
            const previewImg = new Image();
            previewImg.onload = () => {
                canvas.width = previewImg.width;
                canvas.height = previewImg.height;
                ctx.drawImage(previewImg, 0, 0);
            };
            previewImg.src = url;
        }

        function renderFrame(targetCtx, sourceCanvas, size) {
            const border = 8;
            const cx = size / 2;
            const cy = size / 2;
            const outerR = size / 2;
            const innerR = outerR - border;

            targetCtx.clearRect(0, 0, size, size);

            if (document.getElementById('theme2025').checked) {
                targetCtx.fillStyle = '#42464d';
                targetCtx.fillRect(0, 0, size, size);
            }

            // Draw image first (clipped to inner circle)
            targetCtx.save();
            targetCtx.beginPath();
            targetCtx.arc(cx, cy, innerR, 0, Math.PI * 2);
            targetCtx.clip();

            const scale = Math.max((innerR * 2) / sourceCanvas.width, (innerR * 2) / sourceCanvas.height);
            const w = sourceCanvas.width * scale;
            const h = sourceCanvas.height * scale;
            targetCtx.drawImage(sourceCanvas, cx - w/2, cy - h/2, w, h);
            targetCtx.restore();

            // Draw gold gradient ring (as a donut shape, not filled circle)
            const diag = size * 0.7071;
            const grad = targetCtx.createLinearGradient(
                cx - diag, cy - diag,
                cx + diag, cy + diag
            );
            grad.addColorStop(0, 'hsl(49, 99%, 61%)');
            grad.addColorStop(0.2, 'hsl(40, 98%, 59%)');
            grad.addColorStop(0.5, 'hsl(41, 60%, 39%)');
            grad.addColorStop(0.8, 'hsl(42, 49%, 36%)');
            grad.addColorStop(1, 'hsl(49, 99%, 61%)');

            targetCtx.beginPath();
            targetCtx.arc(cx, cy, outerR, 0, Math.PI * 2); // Outer circle clockwise
            targetCtx.arc(cx, cy, innerR, Math.PI * 2, 0, true); // Inner circle counter-clockwise
            targetCtx.fillStyle = grad;
            targetCtx.fill();
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        document.getElementById('theme2025').onchange = async () => {
            if (gifFrames) {
                // Re-process GIF with new theme
                const dims = img._gifDims;
                document.getElementById('progressContainer').classList.remove('hidden');
                downloadBtn.disabled = true;
                await processGifFrames(gifFrames, dims);
            } else if (webpFrames) {
                // Re-process WebP with new theme
                document.getElementById('progressContainer').classList.remove('hidden');
                downloadBtn.disabled = true;
                await processWebPFrames(webpFrames);
            } else if (img) {
                render();
            }
        };

        function render(sourceCanvas = null) {
            const size = Math.max(400, Math.min(img.width, img.height));
            const border = 8;

            canvas.width = size;
            canvas.height = size;

            const cx = size / 2;
            const cy = size / 2;
            const outerR = size / 2;
            const innerR = outerR - border;

            ctx.clearRect(0, 0, size, size);

            if (document.getElementById('theme2025').checked) {
                ctx.fillStyle = '#42464d';
                ctx.fillRect(0, 0, size, size);
            }

            // Draw image first (clipped to inner circle)
            ctx.save();
            ctx.beginPath();
            ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
            ctx.clip();

            const source = sourceCanvas || img;
            const scale = Math.max((innerR * 2) / source.width, (innerR * 2) / source.height);
            const w = source.width * scale;
            const h = source.height * scale;
            ctx.drawImage(source, cx - w/2, cy - h/2, w, h);
            ctx.restore();

            // Draw gold gradient ring (as a donut shape)
            const diag = size * 0.7071;
            const grad = ctx.createLinearGradient(
                cx - diag, cy - diag,
                cx + diag, cy + diag
            );
            grad.addColorStop(0, 'hsl(49, 99%, 61%)');
            grad.addColorStop(0.2, 'hsl(40, 98%, 59%)');
            grad.addColorStop(0.5, 'hsl(41, 60%, 39%)');
            grad.addColorStop(0.8, 'hsl(42, 49%, 36%)');
            grad.addColorStop(1, 'hsl(49, 99%, 61%)');

            ctx.beginPath();
            ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
            ctx.arc(cx, cy, innerR, Math.PI * 2, 0, true);
            ctx.fillStyle = grad;
            ctx.fill();
        }

        function download() {
            const a = document.createElement('a');
            if (isAnimated && gifBlob) {
                a.download = isWebP ? 'gold-profile.webp' : 'gold-profile.gif';
                a.href = URL.createObjectURL(gifBlob);
            } else if (isWebP) {
                a.download = 'gold-profile.webp';
                a.href = canvas.toDataURL('image/webp', 0.95);
            } else {
                a.download = 'gold-profile.png';
                a.href = canvas.toDataURL('image/png');
            }
            a.click();
        }

        // Expose to global scope for onclick handler
        window.download = download;
    </script>
</body>
</html>
